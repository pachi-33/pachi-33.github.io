<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>火鳥</title>
  
  <subtitle>今天依然在摆烂</subtitle>
  <link href="http://pachi-33.github.io/atom.xml" rel="self"/>
  
  <link href="http://pachi-33.github.io/"/>
  <updated>2022-10-23T07:24:37.773Z</updated>
  <id>http://pachi-33.github.io/</id>
  
  <author>
    <name>pachi33</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CMake_常用配置</title>
    <link href="http://pachi-33.github.io/2022/10/23/CMake-%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/"/>
    <id>http://pachi-33.github.io/2022/10/23/CMake-%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/</id>
    <published>2022-10-23T09:16:55.000Z</published>
    <updated>2022-10-23T07:24:37.773Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CMakeLists常用配置"><a href="#CMakeLists常用配置" class="headerlink" title="CMakeLists常用配置"></a>CMakeLists常用配置</h2><p>使用CMake+vscode+CMakeTool进行开发环境的搭建，这里只用到最基础的部分</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>.<span class="number">0</span>)</span><br><span class="line"><span class="keyword">project</span>(main VERSION <span class="number">0.1</span>.<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_COMPILER <span class="string">&quot;g++&quot;</span>)<span class="comment">#设置c++编译器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">aux_source_directory</span>(./src SrcFiles)<span class="comment">#源文件路径，可以设置多个</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(EXECUTABLE_OUTPUT_PATH  <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/debug)<span class="comment">#设置可执行文件输出路径</span></span><br><span class="line"><span class="keyword">add_executable</span>(main <span class="variable">$&#123;SrcFiles&#125;</span>)<span class="comment">#设置可执行文件的名称，make之后bin目录下出现main.exe</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)<span class="comment">#添加头文件的搜索路径</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(main <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib/libeasyx.a)<span class="comment">#添加链接库路径</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="CMakeTool默认配置"><a href="#CMakeTool默认配置" class="headerlink" title="CMakeTool默认配置"></a>CMakeTool默认配置</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>.<span class="number">0</span>)</span><br><span class="line"><span class="keyword">project</span>(mian VERSION <span class="number">0.1</span>.<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(mian main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment">##############################################################################################</span></span><br><span class="line"><span class="keyword">include</span>(CTest)<span class="comment">#CMake自带的测试工具</span></span><br><span class="line"><span class="keyword">enable_testing</span>()<span class="comment">#可以启用测试。一定要在根目录下的CMakeLists.txt中开启，不然执行make test时会报错。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span>(CPack)<span class="comment">#CPack 是 CMake 内置的工具，支持打包成多种格式的安装包</span></span><br><span class="line"><span class="keyword">set</span>(CPACK_PROJECT_NAME <span class="variable">$&#123;PROJECT_NAME&#125;</span>)</span><br><span class="line"><span class="keyword">set</span>(CPACK_PROJECT_VERSION <span class="variable">$&#123;PROJECT_VERSION&#125;</span>)</span><br><span class="line"><span class="comment">###############################################################################################</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;CMakeLists常用配置&quot;&gt;&lt;a href=&quot;#CMakeLists常用配置&quot; class=&quot;headerlink&quot; title=&quot;CMakeLists常用配置&quot;&gt;&lt;/a&gt;CMakeLists常用配置&lt;/h2&gt;&lt;p&gt;使用CMake+vscode+CMakeTo</summary>
      
    
    
    
    <category term="C++学习笔记" scheme="http://pachi-33.github.io/categories/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="CMake" scheme="http://pachi-33.github.io/tags/CMake/"/>
    
  </entry>
  
  <entry>
    <title>C++11并发与多线程学习记录（三）</title>
    <link href="http://pachi-33.github.io/2022/10/23/multipilThread3/"/>
    <id>http://pachi-33.github.io/2022/10/23/multipilThread3/</id>
    <published>2022-10-23T08:35:54.000Z</published>
    <updated>2022-10-23T04:21:13.964Z</updated>
    
    <content type="html"><![CDATA[<h2 id="创建和等待多个线程"><a href="#创建和等待多个线程" class="headerlink" title="创建和等待多个线程"></a>创建和等待多个线程</h2><h3 id="vetor"><a href="#vetor" class="headerlink" title="vetor"></a>vetor</h3><p>​<a href="https://so.csdn.net/so/search?q=vector&spm=1001.2101.3001.7020">vector</a>（称为容器） 是同一种类型的对象的集合,每个对象都有一个对应的整数索引值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myprint</span><span class="params">(<span class="type">int</span> idnum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;我的线程开始执行了，线程编号：&quot;</span> &lt;&lt; idnum &lt;&lt; endl;</span><br><span class="line"><span class="comment">//进行线程内操作</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;我的线程执行结束了，线程编号：&quot;</span> &lt;&lt; idnum &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello World!\n&quot;</span>;</span><br><span class="line"><span class="comment">//创建10个线程</span></span><br><span class="line">vector&lt;thread&gt; mythreads;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)<span class="comment">//创建10个线程，并开始执行</span></span><br><span class="line">&#123;</span><br><span class="line">mythreads.<span class="built_in">push_back</span>(<span class="built_in">thread</span>(myprint, i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter = mythreads.<span class="built_in">begin</span>(); iter != mythreads.<span class="built_in">end</span>(); ++iter)</span><br><span class="line">&#123;</span><br><span class="line">iter-&gt;<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;I love China！&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​运行程序得到的结果是:</p><p><img src="https://img.gejiba.com/images/025d7c9c634f3056ac462a04a6ca88ba.png" alt="025d7c9c634f3056ac462a04a6ca88ba.png"></p><p>​从输出结果来看，多个线程执行顺序是乱的。跟操作系统的运行的调度机制有关；并且建议使用join让主线程等待所有子线程运行结束。</p><h2 id="数据共享问题"><a href="#数据共享问题" class="headerlink" title="数据共享问题"></a>数据共享问题</h2><h3 id="只读的数据"><a href="#只读的数据" class="headerlink" title="只读的数据"></a>只读的数据</h3><p>​只读数据在进行线程间的操作时是安全稳定的，不需要特别的处理手段，直接读就可以；</p><h3 id="有读有写的数据"><a href="#有读有写的数据" class="headerlink" title="有读有写的数据"></a>有读有写的数据</h3><p>​有的线程写有的线程读，不进行特殊处理，那么程序肯定会崩溃；<br>​最简单的处理方式就是读的时候不能写，写的时候不能读，而且同一时刻只能有一个线程对数据进行读或写。</p><h3 id="共享数据"><a href="#共享数据" class="headerlink" title="共享数据"></a>共享数据</h3><p>例程：网络游戏服务器</p><p>服务器有两个线程：</p><p>​其中一个线程收集玩家命令，并把命令数据（用一个数据代表）写到一个队列中。<br>​另外一个线程从队列中取出玩家发送过来的命令，解析并执行玩家的动作<br>本例程中使用list对数据进行管理</p><h4 id="vector和list的对比："><a href="#vector和list的对比：" class="headerlink" title="vector和list的对比："></a>vector和list的对比：</h4><p>​list：进行频繁的按顺序插入和删除数据时效率高。<br>​vector：随机的插入和删除数据时效率高。<br>​对于读和写操作，在对某个数据进行读写操作时，先对数据进行上锁，其他线程要等待该操作完成后对数据解锁后才可以使用。</p><h2 id="保护共享数据"><a href="#保护共享数据" class="headerlink" title="保护共享数据"></a>保护共享数据</h2><h3 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h3><p>​互斥量（mutex）是个类对象，理解成一把锁，当多个线程尝试使用lock()成员函数来加锁时，只有一个线程可以锁成功（成功标志是lock()返回）；如果没锁成功，那么线程会卡在lock()这里不断进行尝试去加锁。<br>​在执行多个线程之间的共享数据的读写操作时，在每一个读写操作之前进行上锁lock()，然后在操作完之后进行解锁unlock()，这样可以保证同一时刻只有一个线程对数据进行处理。</p><h3 id="互斥量的用法"><a href="#互斥量的用法" class="headerlink" title="互斥量的用法"></a>互斥量的用法</h3><p>需要引用头文件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br></pre></td></tr></table></figure><p>创建一个互斥量:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::mutex my_mutex</span><br></pre></td></tr></table></figure><p>操作步骤：先lock()，再操作共享数据，然后再unlock()。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;g_vaul = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;<span class="comment">//共享数据，只读</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//把玩家命令输入到list中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inMsgRecvQueue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;++i)</span><br><span class="line">&#123;</span><br><span class="line">my_mutex.<span class="built_in">lock</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;inMsgRecvQueue执行插入一个元素&quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">msgRecvQueue.<span class="built_in">push_back</span>(i);</span><br><span class="line">my_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从list中取出玩家命令</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">outMsgRecvQueue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">my_mutex.<span class="built_in">lock</span>();</span><br><span class="line"><span class="keyword">if</span> (!msgRecvQueue.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//消息不为空</span></span><br><span class="line"><span class="type">int</span> command = msgRecvQueue.<span class="built_in">front</span>();<span class="comment">//返回第一个元素</span></span><br><span class="line">msgRecvQueue.<span class="built_in">pop_front</span>();<span class="comment">//移除第一个元素但不返回</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;从消息队列中取出一个数据&quot;</span>&lt;&lt; command &lt;&lt; endl;</span><br><span class="line">my_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">my_mutex.<span class="built_in">unlock</span>();<span class="comment">//进行判断时要注意每种情况下都要有对应的unlock()</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;outMsgRecvQueue执行，但是消息队列为空&quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">list&lt;<span class="type">int</span>&gt;msgRecvQueue;</span><br><span class="line">mutex my_mutex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello World!\n&quot;</span>;</span><br><span class="line">A myobja;</span><br><span class="line"><span class="function">thread <span class="title">myOutMsgObj</span><span class="params">(&amp;A::outMsgRecvQueue, &amp;myobja)</span></span>;<span class="comment">//要注意第二个参数是引用才能保证线程中使用的是同一个对象</span></span><br><span class="line"><span class="function">thread <span class="title">myInnMsgObj</span><span class="params">(&amp;A::inMsgRecvQueue, &amp;myobja)</span></span>;</span><br><span class="line">myOutMsgObj.<span class="built_in">join</span>();</span><br><span class="line">myInnMsgObj.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;I love China！&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​线程在遇到mymutex.lock()时会不断尝试lock，直到lock成功才会执行下一行代码。</p><h3 id="std-lock-mutex1-mutex2"><a href="#std-lock-mutex1-mutex2" class="headerlink" title="std::lock(mutex1,mutex2)"></a>std::lock(mutex1,mutex2)</h3><p>​该函数可以lock多个互斥锁，并且只有所有mutex都锁上才会进行下一步，不然会把锁都解开。</p><h3 id="std-lock-guard-lt-std-mutex-gt"><a href="#std-lock-guard-lt-std-mutex-gt" class="headerlink" title="std::lock_guard&lt;std::mutex&gt;"></a>std::lock_guard&lt;<a href="std::mutex">std::mutex</a>&gt;</h3><p>​虽然std::mutex可以对多线程编程中的共享变量提供保护，但是直接使用std::mutex的情况并不多。因为仅<strong>使用std::mutex有时候会发生死锁</strong>。考虑这样一个情况：假设线程1上锁成功，线程2上锁等待。但是线程1上锁成功后，抛出异常并退出，没有来得及释放锁，导致线程2“永久的等待下去”（线程2：我的心在等待永远在等待……），此时就发生了死锁。</p><p>​避免死锁，lock_guard:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line">std::mutex mtx; <span class="comment">// 保护counter</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increase_proxy</span><span class="params">(<span class="type">int</span> time, <span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; time; i++) &#123;</span><br><span class="line">        <span class="comment">// std::lock_guard对象构造时，自动调用mtx.lock()进行上锁</span></span><br><span class="line">        <span class="comment">// std::lock_guard对象析构时，自动调用mtx.unlock()释放锁</span></span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        <span class="comment">// 线程1上锁成功后，抛出异常：未释放锁</span></span><br><span class="line">        <span class="keyword">if</span> (id == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;throw excption....&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前线程休眠1毫秒</span></span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">1</span>));</span><br><span class="line">        counter++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increase</span><span class="params">(<span class="type">int</span> time, <span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">increase_proxy</span>(time, id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e)&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;id:&quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(increase, <span class="number">10000</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(increase, <span class="number">10000</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;counter:&quot;</span> &lt;&lt; counter &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​执行上述代码，结果为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@<span class="number">2</span>d129aac5cc5 demo]# ./mutex_demo4_lock_guard</span><br><span class="line">id:<span class="number">1</span>, <span class="keyword">throw</span> excption....</span><br><span class="line">counter:<span class="number">10000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​结果符合预期，lock_guard类似于一个智能指针。所以，<strong>推荐使用std::mutex和std::lock_guard搭配使用，避免死锁的发生</strong>。</p><h3 id="std-lock-guard的第二个构造函数"><a href="#std-lock-guard的第二个构造函数" class="headerlink" title="std::lock_guard的第二个构造函数"></a>std::lock_guard的第二个构造函数</h3><p>​实际上，std::lock_guard有两个构造函数，具体的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">lock_guard</span><span class="params">( mutex_type&amp; m )</span></span>;                   (<span class="number">1</span>)      (since C++<span class="number">11</span>)</span><br><span class="line"><span class="built_in">lock_guard</span>( mutex_type&amp; m, std::<span class="type">adopt_lock_t</span> t );     (<span class="number">2</span>)      (since C++<span class="number">11</span>)</span><br><span class="line"><span class="built_in">lock_guard</span>( <span class="type">const</span> lock_guard&amp; ) = <span class="keyword">delete</span>;               (<span class="number">3</span>)      (since C++<span class="number">11</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​第2个构造函数有两个参数，其中第二个参数类型为：std::adopt_lock_t。这个构造函数假定：当前线程已经上锁成功，所以不再调用lock()函数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;创建和等待多个线程&quot;&gt;&lt;a href=&quot;#创建和等待多个线程&quot; class=&quot;headerlink&quot; title=&quot;创建和等待多个线程&quot;&gt;&lt;/a&gt;创建和等待多个线程&lt;/h2&gt;&lt;h3 id=&quot;vetor&quot;&gt;&lt;a href=&quot;#vetor&quot; class=&quot;header</summary>
      
    
    
    
    <category term="C++学习笔记" scheme="http://pachi-33.github.io/categories/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="多线程" scheme="http://pachi-33.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>二叉树</title>
    <link href="http://pachi-33.github.io/2022/09/03/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://pachi-33.github.io/2022/09/03/%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2022-09-03T02:26:07.000Z</published>
    <updated>2022-09-03T02:39:11.211Z</updated>
    
    <content type="html"><![CDATA[<div class="flink"><div class="flink-name">数据结构</div><div class="flink-desc">转载 from CSDN</div> <div class="flink-list">          <div class="flink-list-item">            <a href="https://blog.csdn.net/qq_43762191/article/details/107280503?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166205205516780357215187%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=166205205516780357215187&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~pc_rank_34-8-107280503-null-null.142^v44^pc_rank_34_ecpm25&utm_term=%E6%A0%91%E6%97%8B%E8%BD%AC&spm=1018.2226.3001.4187" title="看，未来" target="_blank">              <div class="flink-item-icon">                <img class="no-lightbox" src="https://profile-avatar.csdnimg.cn/497a4af045284129885c97a2abed430b_qq_43762191.jpg!1" onerror='this.onerror=null;this.src="/img/friend_404.gif"' alt="看，未来" />              </div>              <div class="flink-item-name">看，未来</div>               <div class="flink-item-desc" title="https://lion-wu.blog.csdn.net/?type=blog">https://lion-wu.blog.csdn.net/?type=blog</div>            </a>          </div></div></div>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;flink&quot;&gt;&lt;div class=&quot;flink-name&quot;&gt;数据结构&lt;/div&gt;&lt;div class=&quot;flink-desc&quot;&gt;转载 from CSDN&lt;/div&gt; &lt;div class=&quot;flink-list&quot;&gt;
          &lt;div clas</summary>
      
    
    
    
    <category term="数据结构" scheme="http://pachi-33.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="二叉树基础" scheme="http://pachi-33.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>unique_ptr源码分析</title>
    <link href="http://pachi-33.github.io/2022/08/25/unique-ptr/"/>
    <id>http://pachi-33.github.io/2022/08/25/unique-ptr/</id>
    <published>2022-08-25T04:48:35.000Z</published>
    <updated>2022-08-25T05:01:39.375Z</updated>
    
    <content type="html"><![CDATA[<h2 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h2><p>​管理指针的存储，提供有限的垃圾回收工具，与内置指针相比几乎没有开销（取决于所使用的删除程序）。</p><p>​这些对象具有获取指针所有权的能力：一旦它们获得所有权，它们就会通过在某个时候负责删除指向的对象来管理指向的对象。</p><p>​unique_ptr对象在它们本身被销毁时，或者一旦它们的值通过赋值操作或显式调用unique_ptr::reset而改变，就会自动删除它们所管理的对象（使用删除器）。</p><p>​unique_ptr对象唯一地拥有其指针：任何其他工具都不应负责删除该对象，因此任何其他托管指针都不应指向其托管对象，因为一旦它们必须这样做，unique_ptr对象就会删除其托管对象，而不考虑其他指针是否仍指向同一对象， 从而将指向那里的任何其他指针保留为指向无效位置。</p><h3 id="unique-ptr对象有两个组件："><a href="#unique-ptr对象有两个组件：" class="headerlink" title="unique_ptr对象有两个组件："></a>unique_ptr对象有两个组件：</h3><h4 id="存储的指针："><a href="#存储的指针：" class="headerlink" title="存储的指针："></a>存储的指针：</h4><p>​指向它所管理的对象的指针。这是在构造时设置的，可以通过赋值操作或调用成员重置进行更改，并且可以单独访问以使用成员获取或释放进行读取。</p><h4 id="存储的删除程序："><a href="#存储的删除程序：" class="headerlink" title="存储的删除程序："></a>存储的删除程序：</h4><p>​一个可调用对象，它采用与存储指针类型相同的参数，并被调用以删除托管对象。它在施工时设置，可以通过分配操作进行更改，并且可以使用成员get_deleter单独访问。</p><p>​unique_ptr对象通过运算符 * 和 -&gt;（对于单个对象）或运算符 []（对于数组对象）提供对其托管对象的访问来复制有限的指针功能。出于安全原因，它们不支持指针算术，仅支持移动分配（禁用复制分配）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Ty&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myDeletor</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">myDeletor</span>() = <span class="keyword">default</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(_Ty* ptr)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (ptr != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Ty&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myDeletor</span>&lt;_Ty[]&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">myDeletor</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(_Ty* ptr)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (ptr != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span>[]ptr;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// my_unique_ptr</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Ty, <span class="keyword">typename</span> _Dx = myDeletor&lt;_Ty&gt; &gt;</span><br><span class="line"><span class="keyword">class</span> my_unique_ptr</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">using</span> pointer = _Ty*;</span><br><span class="line"><span class="keyword">using</span> element_type = _Ty;</span><br><span class="line"><span class="keyword">using</span> delete_type = _Dx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">pointer _Ptr;</span><br><span class="line">delete_type _myDeletor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">my_unique_ptr</span>(<span class="type">const</span> my_unique_ptr&amp; _Y) = <span class="keyword">delete</span>;</span><br><span class="line">my_unique_ptr <span class="keyword">operator</span> =(<span class="type">const</span> my_unique_ptr&amp; _Y) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">my_unique_ptr</span>(pointer _P = <span class="literal">nullptr</span>)</span><br><span class="line">: _Ptr(_P)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;my_unique_ptr: &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">my_unique_ptr</span>() &#123;</span><br><span class="line"><span class="keyword">if</span> (_Ptr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">_myDeletor(_Ptr);</span><br><span class="line">_Ptr = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;~my_unique_ptr: &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">_Dx&amp; <span class="title">get_deletor</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> _myDeletor;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">const</span> _Dx&amp; <span class="title">get_deletor</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> _myDeletor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">pointer <span class="title">get_pointer</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> _Ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> _Ptr != <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_Ty&amp; <span class="keyword">operator</span>*() <span class="type">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> *_Ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pointer <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;**<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">pointer <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">pointer old = _Ptr;</span><br><span class="line">_Ptr = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(pointer _P = <span class="literal">nullptr</span>)</span> </span>&#123;</span><br><span class="line">pointer old = _Ptr;</span><br><span class="line">_Ptr = _P;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (old != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">_myDeletor(old);</span><br><span class="line"><span class="comment">// get_deletor()(old);</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(my_unique_ptr _Y)</span> </span>&#123;</span><br><span class="line">std::<span class="built_in">swap</span>(_Ptr, _Y._Ptr);</span><br><span class="line">std::<span class="built_in">swap</span>(_myDeletor, _Y._myDeletor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">my_unique_ptr</span>(my_unique_ptr&amp;&amp; _Y) &#123;</span><br><span class="line">_Ptr = _Y._Ptr;</span><br><span class="line">_Y = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">my_unique_ptr&amp; <span class="keyword">operator</span>=(my_unique_ptr&amp;&amp; _Y) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> == &amp;_Y) &#123;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">reset</span>(_Y.<span class="built_in">release</span>());</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// array</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Ty, <span class="keyword">typename</span> _Dx&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">my_unique_ptr</span>&lt;_Ty[], _Dx&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">using</span> pointer = _Ty*;</span><br><span class="line"><span class="keyword">using</span> element_type = _Ty;</span><br><span class="line"><span class="keyword">using</span> delete_type = _Dx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">pointer _Ptr;</span><br><span class="line">delete_type _myDeletor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">my_unique_ptr</span>(<span class="type">const</span> my_unique_ptr&amp; _Y) = <span class="keyword">delete</span>;</span><br><span class="line">my_unique_ptr <span class="keyword">operator</span> =(<span class="type">const</span> my_unique_ptr&amp; _Y) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">my_unique_ptr</span>(pointer _P = <span class="literal">nullptr</span>)</span><br><span class="line">: _Ptr(_P)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;my_unique_ptr: &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">my_unique_ptr</span>() &#123;</span><br><span class="line"><span class="keyword">if</span> (_Ptr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">_myDeletor(_Ptr);</span><br><span class="line">_Ptr = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;~my_unique_ptr: &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">_Dx&amp; <span class="title">get_deletor</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> _myDeletor;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">const</span> _Dx&amp; <span class="title">get_deletor</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> _myDeletor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">pointer <span class="title">get_pointer</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> _Ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> _Ptr != <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_Ty&amp; <span class="keyword">operator</span>*() <span class="type">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> *_Ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pointer <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;**<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">pointer <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">pointer old = _Ptr;</span><br><span class="line">_Ptr = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(pointer _P = <span class="literal">nullptr</span>)</span> </span>&#123;</span><br><span class="line">pointer old = _Ptr;</span><br><span class="line">_Ptr = _P;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (old != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">_myDeletor(old);</span><br><span class="line"><span class="comment">// get_deletor()(old);</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(my_unique_ptr _Y)</span> </span>&#123;</span><br><span class="line">std::<span class="built_in">swap</span>(_Ptr, _Y._Ptr);</span><br><span class="line">std::<span class="built_in">swap</span>(_myDeletor, _Y._myDeletor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">my_unique_ptr</span>(my_unique_ptr&amp;&amp; _Y) &#123;</span><br><span class="line">_Ptr = _Y._Ptr;</span><br><span class="line">_Y = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">my_unique_ptr&amp; <span class="keyword">operator</span>=(my_unique_ptr&amp;&amp; _Y) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> == &amp;_Y) &#123;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">reset</span>(_Y.<span class="built_in">release</span>());</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_Ty&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> _Idx) <span class="type">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> _Ptr[_Idx];</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Ty, <span class="keyword">typename</span> ... _Type&gt;</span></span><br><span class="line"><span class="function">my_unique_ptr&lt;_Ty&gt; <span class="title">my_make_unique</span><span class="params">(_Type&amp;&amp; ... _args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">my_unique_ptr</span>&lt;_Ty&gt;(<span class="keyword">new</span> _Ty(_args...));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;unique-ptr&quot;&gt;&lt;a href=&quot;#unique-ptr&quot; class=&quot;headerlink&quot; title=&quot;unique_ptr&quot;&gt;&lt;/a&gt;unique_ptr&lt;/h2&gt;&lt;p&gt;​	管理指针的存储，提供有限的垃圾回收工具，与内置指针相比几乎没有开销（取决</summary>
      
    
    
    
    <category term="C++学习笔记" scheme="http://pachi-33.github.io/categories/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="智能指针" scheme="http://pachi-33.github.io/tags/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>C++11并发与多线程学习记录（二）</title>
    <link href="http://pachi-33.github.io/2022/08/24/multipilThread2/"/>
    <id>http://pachi-33.github.io/2022/08/24/multipilThread2/</id>
    <published>2022-08-24T15:12:15.000Z</published>
    <updated>2022-09-03T02:19:39.061Z</updated>
    
    <content type="html"><![CDATA[<h2 id="传递临时对象作为线程参数"><a href="#传递临时对象作为线程参数" class="headerlink" title="传递临时对象作为线程参数:"></a>传递临时对象作为线程参数:</h2><p>​使用显示类型转换，保证参数在该处完成类型转换，否则该参数可能在主线程结束后仍未完成转换。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_i;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> a):<span class="built_in">m_i</span>(a)&#123;cout&lt;&lt;<span class="string">&quot;[A::A(int a)构造函数执行]&quot;</span>&lt;&lt;<span class="keyword">this</span>&lt;&lt;endl;&#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A&amp;a):<span class="built_in">m_i</span>(a.m_i)&#123;cout&lt;&lt;<span class="string">&quot;[A::A(const A)拷贝构造函数执行&quot;</span>&lt;&lt;<span class="keyword">this</span>&lt;&lt;endl;&#125;</span><br><span class="line">    ~<span class="built_in">A</span>()&#123;cout&lt;&lt;<span class="string">&quot;[A::~A()析构函数执行]&quot;</span>&lt;&lt;<span class="keyword">this</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(<span class="type">const</span> <span class="type">int</span> i, <span class="type">const</span> A &amp;pmybuf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;&amp;pmybuf&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> mvar=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> mysecondpar=<span class="number">12</span>;</span><br><span class="line">    <span class="function">thread <span class="title">mytobj</span><span class="params">(myPrint,mvar,A(<span class="number">12</span>))</span></span>;<span class="comment">//避免隐式类型转换,在创建线程时构建临时对象,并用引用传参</span></span><br><span class="line">    mytobj.<span class="built_in">detach</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程id的概念"><a href="#线程id的概念" class="headerlink" title="线程id的概念"></a>线程id的概念</h3><p>​线程id是个数字，不管是主线程还是子线程都对应一个数字，每个线程对应的线程id不同。线程id可以用标准库里的函数<code>std::this_thread::get_id()</code>来获取。</p><h3 id="临时对象构造时机的捕获"><a href="#临时对象构造时机的捕获" class="headerlink" title="临时对象构造时机的捕获"></a>临时对象构造时机的捕获</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_i;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> a):<span class="built_in">m_i</span>(a)&#123;cout&lt;&lt;<span class="string">&quot;[A::A(int a)构造函数执行]&quot;</span>&lt;&lt;<span class="string">&quot;threadID=&quot;</span>&lt;&lt;std::this_thread::<span class="built_in">get_id</span>()&lt;&lt;endl;&#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A&amp;a):<span class="built_in">m_i</span>(a.m_i)&#123;cout&lt;&lt;<span class="string">&quot;[A::A(const A)拷贝构造函数执行&quot;</span>&lt;&lt;<span class="string">&quot;threadID=&quot;</span>&lt;&lt;std::this_thread::<span class="built_in">get_id</span>()&lt;&lt;endl;&#125;</span><br><span class="line">    ~<span class="built_in">A</span>()&#123;cout&lt;&lt;<span class="string">&quot;[A::~A()析构函数执行]&quot;</span>&lt;&lt;<span class="string">&quot;threadID=&quot;</span>&lt;&lt;std::this_thread::<span class="built_in">get_id</span>()&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(<span class="type">const</span> <span class="type">int</span> i, <span class="type">const</span> A &amp;pmybuf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;&amp;pmybuf&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//cout&lt;&lt;pmybuf&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> mvar=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> mysecondpar=<span class="number">12</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;主线程ID=&quot;</span>&lt;&lt;std::this_thread::<span class="built_in">get_id</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="function">thread <span class="title">mytobj</span><span class="params">(myPrint,mvar,A(<span class="number">12</span>))</span></span>;</span><br><span class="line">    mytobj.<span class="built_in">join</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="传递类对象作为线程参数"><a href="#传递类对象作为线程参数" class="headerlink" title="传递类对象作为线程参数"></a>传递类对象作为线程参数</h2><p>​使用类的仿函数做线程参数，重写拷贝构造函数为深拷贝。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyPrint</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//有参构造</span></span><br><span class="line"><span class="built_in">MyPrint</span>(<span class="type">const</span> <span class="type">int</span> i, string buf) &#123;</span><br><span class="line">m_i = i;</span><br><span class="line">m_buf = <span class="keyword">new</span> <span class="built_in">string</span>(buf);</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;constructor with arguments:&quot;</span>&lt;&lt;<span class="keyword">this</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拷贝构造函数</span></span><br><span class="line"><span class="built_in">MyPrint</span>(<span class="type">const</span> MyPrint &amp;p) &#123;</span><br><span class="line">m_i = p.m_i;</span><br><span class="line">m_buf = <span class="keyword">new</span> <span class="built_in">string</span>(*p.m_buf);</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;copy constructor:&quot;</span>&lt;&lt;<span class="keyword">this</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//析构函数</span></span><br><span class="line">~<span class="built_in">MyPrint</span>() &#123;</span><br><span class="line"><span class="comment">//对申请的堆进行释放</span></span><br><span class="line"><span class="keyword">if</span> (m_buf) &#123;</span><br><span class="line"><span class="keyword">delete</span> m_buf;</span><br><span class="line">m_buf = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;destructor:&quot;</span>&lt;&lt;<span class="keyword">this</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;===============&quot;</span>&lt;&lt;endl;</span><br><span class="line">cout &lt;&lt; m_i &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; *m_buf &lt;&lt; endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;===============&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m_i;</span><br><span class="line">string* m_buf; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="function">string <span class="title">mybuf</span><span class="params">(<span class="string">&quot;this is a test!&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">MyPrint <span class="title">p</span><span class="params">(i, mybuf)</span></span>;</span><br><span class="line"><span class="comment">//创建线程</span></span><br><span class="line"><span class="function">thread <span class="title">mythread</span><span class="params">(p)</span></span>; <span class="comment">//线程的函数传参直接顺序写到后面即可</span></span><br><span class="line"></span><br><span class="line">mythread.<span class="built_in">detach</span>();</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;end&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="传递智能指针作为线程参数"><a href="#传递智能指针作为线程参数" class="headerlink" title="传递智能指针作为线程参数"></a>传递智能指针作为线程参数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(unique_ptr&lt;<span class="type">int</span>&gt; ptn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;thread = &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">up</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line"><span class="function">thread <span class="title">mythread</span><span class="params">(myPrint, std::move(up))</span></span>;</span><br><span class="line">mythread.<span class="built_in">join</span>();</span><br><span class="line"><span class="comment">//mythread.detach();</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>1.独占式指针只能通过std::move()才可以传递给另一个指针<br>2.传递后up就指向空，新的ptn指向原来的内存<br>3.所以这时就不能用detach了，因为如果主线程先执行完，ptn指向的对象就被释放了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;传递临时对象作为线程参数&quot;&gt;&lt;a href=&quot;#传递临时对象作为线程参数&quot; class=&quot;headerlink&quot; title=&quot;传递临时对象作为线程参数:&quot;&gt;&lt;/a&gt;传递临时对象作为线程参数:&lt;/h2&gt;&lt;p&gt;​	使用显示类型转换，保证参数在该处完成类型转换，否则该</summary>
      
    
    
    
    <category term="C++学习笔记" scheme="http://pachi-33.github.io/categories/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="多线程" scheme="http://pachi-33.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>string源码分析</title>
    <link href="http://pachi-33.github.io/2022/08/16/string/"/>
    <id>http://pachi-33.github.io/2022/08/16/string/</id>
    <published>2022-08-16T06:40:29.000Z</published>
    <updated>2022-08-18T08:41:32.993Z</updated>
    
    <content type="html"><![CDATA[<h3 id="stiring-相比于c-string-要方便多了，string里有很多的库函数，现在来把库函数实现下"><a href="#stiring-相比于c-string-要方便多了，string里有很多的库函数，现在来把库函数实现下" class="headerlink" title="stiring 相比于c-string 要方便多了，string里有很多的库函数，现在来把库函数实现下:"></a>stiring 相比于c-string 要方便多了，string里有很多的<a href="https://so.csdn.net/so/search?q=%E5%BA%93%E5%87%BD%E6%95%B0&spm=1001.2101.3001.7020">库函数</a>，现在来把库函数实现下:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">my_string</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">char</span>* _str;</span><br><span class="line">        std::<span class="type">size_t</span> _size;<span class="comment">//元素的个数，容器的实际使用空间。</span></span><br><span class="line">        std::<span class="type">size_t</span> _capacity;<span class="comment">//容器的预留空间，容器的容量,容器在内存中开辟的存储空间的总大小。</span></span><br><span class="line">        <span class="type">static</span> <span class="type">size_t</span> npos;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">typedef</span> <span class="type">char</span>* iterator;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="type">const</span> <span class="type">char</span>* const_iterator;</span><br><span class="line"></span><br><span class="line">        <span class="function">const_iterator <span class="title">begin</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> _str;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">const_iterator <span class="title">end</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> _str+_size;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">iterator <span class="title">begin</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> _str;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">iterator <span class="title">end</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> _str+_size;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">char</span>* <span class="title">strStr</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str1,<span class="type">const</span> <span class="type">char</span>* str2)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(*str2)&#123;</span><br><span class="line">                <span class="keyword">while</span>(*str1)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;*(str1+i)==*(str2+i);i++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(!*(str2+i+<span class="number">1</span>))&#123;</span><br><span class="line">                            <span class="keyword">return</span> (<span class="type">char</span>*)str1;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                str1++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">return</span> (<span class="type">char</span>*) str1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">char</span>* <span class="title">strcpy</span><span class="params">(<span class="type">char</span>* dest,<span class="type">const</span> <span class="type">char</span> src[])</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(dest==<span class="literal">nullptr</span>||src==<span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(*src!=<span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dest[i++]=*(src++);</span><br><span class="line">            &#125;</span><br><span class="line">            dest[i]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            <span class="keyword">return</span> dest;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">size_t</span> <span class="title">strlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="type">size_t</span> len=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((*str++!=<span class="string">&#x27;\0&#x27;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                len++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> len;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Reserve扩容</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Reserve</span><span class="params">(<span class="type">size_t</span> n)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(n==<span class="number">0</span>||n&gt;_capacity)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">size_t</span> newsize = n;</span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">8</span> != <span class="number">0</span>)</span><br><span class="line">    newsize = (n / <span class="number">8</span> + <span class="number">1</span>) * <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    newsize = n + <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">                <span class="type">char</span>* newstr=<span class="keyword">new</span> <span class="type">char</span>[newsize];</span><br><span class="line">                <span class="keyword">if</span>(_str) <span class="built_in">strcpy</span>(newstr,_str);</span><br><span class="line">                <span class="keyword">delete</span>[] _str;</span><br><span class="line">                _str=newstr;</span><br><span class="line">                _capacity=newsize<span class="number">-1</span>;  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Resize扩容</span></span><br><span class="line">        <span class="function"><span class="type">void</span>  <span class="title">Resize</span><span class="params">(<span class="type">size_t</span> n,<span class="type">char</span> ch=<span class="string">&#x27;\0&#x27;</span>)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(n&lt;=_size)&#123;</span><br><span class="line">                _size=n;</span><br><span class="line">                _str[_size]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">Reserve</span>(n);</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">size_t</span> i=_size;i&lt;n;i++)&#123;</span><br><span class="line">                    _str[i]=ch;</span><br><span class="line">                    _size++;</span><br><span class="line">                &#125;</span><br><span class="line">                _str[_size]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//c_str接口</span></span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">c_str</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//size()接口</span></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">Size</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//capacity()接口</span></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">Capacity</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//s1.Swap(s2)方法，便于交换，效率优于swap(s1,s2);免去了2步拷贝构造</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(my_string&amp; s)</span></span>&#123;</span><br><span class="line">    std::<span class="built_in">swap</span>(_str, s._str);</span><br><span class="line">    std::<span class="built_in">swap</span>(_size, s._size);</span><br><span class="line">    std::<span class="built_in">swap</span>(_capacity, s._capacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">my_string</span>()&#123;</span><br><span class="line">            cout&lt;&lt;<span class="keyword">this</span>&lt;&lt;<span class="string">&quot;: &quot;</span>;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;默认构造函数已运行&quot;</span>&lt;&lt;endl;</span><br><span class="line">            _str=<span class="literal">nullptr</span>;</span><br><span class="line">            _size=<span class="number">0</span>;</span><br><span class="line">            _capacity=<span class="number">0</span>;</span><br><span class="line">            <span class="built_in">Reserve</span>(_size);</span><br><span class="line">            _str[<span class="number">0</span>]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">my_string</span>(<span class="type">const</span> <span class="type">char</span>* in_char_ptr)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="keyword">this</span>&lt;&lt;<span class="string">&quot;: &quot;</span>;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;初始化构造函数已运行&quot;</span>&lt;&lt;endl;</span><br><span class="line">            _str=<span class="literal">nullptr</span>;</span><br><span class="line">            _size=<span class="built_in">strlen</span>(in_char_ptr);</span><br><span class="line">            _capacity=<span class="number">0</span>;</span><br><span class="line">            <span class="built_in">Reserve</span>(_size);</span><br><span class="line">            <span class="built_in">strcpy</span>(_str,in_char_ptr);  </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">my_string</span>(<span class="type">const</span> my_string&amp; in_str)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="keyword">this</span>&lt;&lt;<span class="string">&quot;: &quot;</span>;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;拷贝构造函数已运行 from:&quot;</span>&lt;&lt;&amp;in_str&lt;&lt;endl;</span><br><span class="line">            <span class="function">my_string <span class="title">tmp</span><span class="params">(in_str._str)</span></span>;</span><br><span class="line">            <span class="keyword">this</span>-&gt;<span class="built_in">Swap</span>(tmp);</span><br><span class="line">            tmp._str=<span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ~<span class="built_in">my_string</span>()&#123;</span><br><span class="line">            <span class="keyword">if</span>(_str)&#123;</span><br><span class="line">                cout&lt;&lt;<span class="keyword">this</span>&lt;&lt;<span class="string">&quot;: &quot;</span>;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;析构函数已运行&quot;</span>&lt;&lt;endl;</span><br><span class="line">                <span class="keyword">delete</span>[] _str;</span><br><span class="line">                _str=<span class="literal">nullptr</span>;</span><br><span class="line">                _size=_capacity=<span class="number">0</span>;</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        my_string&amp; <span class="keyword">operator</span>=(my_string s)&#123;</span><br><span class="line">    <span class="built_in">Swap</span>(s);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//插入字符</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">size_t</span> pos,<span class="type">char</span> ch)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(_size==_capacity)&#123;</span><br><span class="line">                <span class="built_in">Reserve</span>(_capacity*<span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">size_t</span> i=_size;i&gt;pos;--i)&#123;</span><br><span class="line">                _str[i]=_str[i<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            _str[pos]=ch;</span><br><span class="line">            _size++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//插入字符串</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">size_t</span> pos,<span class="type">const</span> <span class="type">char</span>* str)</span></span>&#123;</span><br><span class="line">            <span class="type">size_t</span> len=<span class="built_in">strlen</span>(str);</span><br><span class="line">            <span class="keyword">if</span>(len+_size&gt;_capacity)&#123;</span><br><span class="line">                <span class="built_in">Reserve</span>(len+_size);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">size_t</span> i=_size;i&gt;pos;--i)&#123;</span><br><span class="line">                _str[i+len]=_str[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">strcpy</span>(_str+pos,str);</span><br><span class="line">            _size+=len;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//追加字符</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">PushBack</span><span class="params">(<span class="type">char</span> ch)</span></span>&#123;</span><br><span class="line">            <span class="built_in">Insert</span>(_size,ch);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//追加字符串</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Append</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str)</span></span>&#123;</span><br><span class="line">            <span class="built_in">Insert</span>(_size,str);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        my_string&amp; <span class="keyword">operator</span>+=(<span class="type">char</span> ch)&#123;</span><br><span class="line">            <span class="built_in">PushBack</span>(ch);</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        my_string&amp; <span class="keyword">operator</span>+=(<span class="type">const</span> <span class="type">char</span>* str)&#123;</span><br><span class="line">            <span class="built_in">Append</span>(str);</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关系运算符重载</span></span><br><span class="line">        <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> my_string&amp; s)<span class="type">const</span>&#123;</span><br><span class="line">            <span class="type">size_t</span> i=<span class="number">0</span>;</span><br><span class="line">            <span class="type">size_t</span> j=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;_size &amp;&amp; j&lt;s._size)&#123;</span><br><span class="line">                <span class="keyword">if</span>(_str[i]&lt;s._str[j])&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(_str[i]&gt;s._str[j])&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    ++i;</span><br><span class="line">                    ++j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="comment">//end</span></span><br><span class="line">            <span class="keyword">if</span>(j&lt;s._size)&#123; <span class="comment">//左值字符串长度小于右值</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;          <span class="comment">//左值字符串长度大于右值</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">bool</span> <span class="keyword">operator</span>&lt;=(<span class="type">const</span> my_string&amp; s)<span class="type">const</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> *<span class="built_in">this</span>&lt;s||*<span class="keyword">this</span>==s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> my_string&amp; s)<span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> !(*<span class="keyword">this</span> &lt;= s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&gt;=(<span class="type">const</span> my_string&amp; s)<span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> !(*<span class="keyword">this</span> &lt; s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> my_string&amp; s)<span class="type">const</span>&#123;</span><br><span class="line">            <span class="type">size_t</span> i=<span class="number">0</span>;</span><br><span class="line">            <span class="type">size_t</span> j=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;_size&amp;&amp;j&lt;s._size)&#123;</span><br><span class="line">                <span class="keyword">if</span>(_str[i]!=s._str[j])&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    ++i;</span><br><span class="line">                    ++j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="comment">//end</span></span><br><span class="line">            <span class="keyword">if</span>(i==_size&amp;&amp;j==s._size)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> my_string&amp; s)<span class="type">const</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> !(*<span class="keyword">this</span>==s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//运算符重载</span></span><br><span class="line">        my_string <span class="keyword">operator</span>+(<span class="type">const</span> <span class="type">char</span> ch)<span class="type">const</span>&#123;</span><br><span class="line">            <span class="function">my_string <span class="title">tmp</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">            tmp.<span class="built_in">PushBack</span>(ch);</span><br><span class="line">            <span class="keyword">return</span> tmp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        my_string <span class="keyword">operator</span>+(<span class="type">const</span> <span class="type">char</span>* str)<span class="type">const</span>&#123;</span><br><span class="line">    <span class="function">my_string <span class="title">tmp</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    tmp.<span class="built_in">Append</span>(str);</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//operator[]运算符重载</span></span><br><span class="line">    <span class="type">char</span>&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> pos)&#123;</span><br><span class="line">    <span class="keyword">return</span> _str[pos];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//operator[]运算符重载 const</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> pos) <span class="type">const</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _str[pos];</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">        <span class="comment">//查找：返回数据下标</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//查找字符接口</span></span><br><span class="line">        <span class="function"><span class="type">size_t</span> <span class="title">Find</span><span class="params">(<span class="type">const</span> <span class="type">char</span> ch,<span class="type">size_t</span> pos=<span class="number">0</span>)</span></span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">size_t</span> i=pos;i&lt;=_size;++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(*(_str+i)==ch)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> npos;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//查找字符串接口</span></span><br><span class="line">        <span class="function"><span class="type">size_t</span> <span class="title">Find</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str,<span class="type">size_t</span> pos=<span class="number">0</span>)</span></span>&#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">char</span>* ret=<span class="built_in">strStr</span>(_str+pos,str);</span><br><span class="line">            <span class="keyword">if</span>(ret==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> npos;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> ret-_str;</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,<span class="type">const</span> my_string&amp; item)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">size_t</span> i=<span class="number">0</span>;i&lt;item.<span class="built_in">Size</span>();i++)&#123;</span><br><span class="line">                os&lt;&lt;item[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> os;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="type">size_t</span> my_string::npos=<span class="number">-1</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;stiring-相比于c-string-要方便多了，string里有很多的库函数，现在来把库函数实现下&quot;&gt;&lt;a href=&quot;#stiring-相比于c-string-要方便多了，string里有很多的库函数，现在来把库函数实现下&quot; class=&quot;headerlin</summary>
      
    
    
    
    <category term="C++基础" scheme="http://pachi-33.github.io/categories/C-%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="string" scheme="http://pachi-33.github.io/tags/string/"/>
    
    <category term="源码" scheme="http://pachi-33.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>shared_ptr源码分析</title>
    <link href="http://pachi-33.github.io/2022/08/15/shared-ptr/"/>
    <id>http://pachi-33.github.io/2022/08/15/shared-ptr/</id>
    <published>2022-08-15T04:19:21.000Z</published>
    <updated>2022-08-25T04:55:56.270Z</updated>
    
    <content type="html"><![CDATA[<h3 id="shared-ptr的原理："><a href="#shared-ptr的原理：" class="headerlink" title="shared_ptr的原理："></a>shared_ptr的原理：</h3><p>通过引用计数的方式来实现多个shared_ptr对象之间共享资源。</p><p>1.shaed_ptr在其内部，给每个资源都维护了着一份计数，用来记录该份资源被几个对象共享。<br>2.在对象被销毁时(也就是析构函数调用)，就说明自己不使用该资源了，对象的引用计数减一。<br>3.如果引用计数是0，就说明自己是最后一个使用该资源的对象，必须释放该资源；<br>4.如果不是0，就说明除了自己还有其他对象在使用该份资源，不能释放该资源，否则其他对象就成野指针了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">shared_ptr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">shared_ptr</span>(T* p)</span><br><span class="line">:_ptr(p)</span><br><span class="line">, _pCount(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1</span>))</span><br><span class="line">, _pMtx(<span class="keyword">new</span> mutex)</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="comment">//做到代码的复用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Release</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">bool</span> dFlag = <span class="literal">false</span>;</span><br><span class="line">_pMtx-&gt;<span class="built_in">lock</span>();</span><br><span class="line"><span class="comment">//对于在堆上所开辟的锁资源也应该进行释放</span></span><br><span class="line"><span class="comment">//unique_lock&lt;mutex&gt; lock(*_pMtx);</span></span><br><span class="line"><span class="keyword">if</span> (--(*_pCount) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (_ptr)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> _ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> _pCount;</span><br><span class="line">dFlag = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">_pMtx-&gt;<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dFlag)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> _pMtx;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddUseCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(*_pMtx)</span></span>;</span><br><span class="line">++(*_pCount);</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">shared_ptr</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">Release</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">shared_ptr</span>(<span class="type">const</span> shared_ptr&lt;T&gt;&amp; sp)</span><br><span class="line">:_ptr(sp._ptr)</span><br><span class="line">, _pCount(sp._pCount)</span><br><span class="line">, _pMtx(sp._pMtx)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//++(*_pCount);</span></span><br><span class="line"><span class="built_in">AddUseCount</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//sp1 = sp3</span></span><br><span class="line"></span><br><span class="line">shared_ptr&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="type">const</span> shared_ptr&lt;T&gt;&amp; sp)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//这前三行代码就是直接将sp1所指向的空间进行修改，但是这样做是有问题的，因为会造成内存的泄漏，因为sp2哪里的_pCount还是2</span></span><br><span class="line"><span class="comment">//他永远也不会减到0了，也就对这块空间没办法进行释放了</span></span><br><span class="line"><span class="comment">//_ptr = sp._ptr;</span></span><br><span class="line"><span class="comment">//_pCount = sp._pCount;</span></span><br><span class="line"><span class="comment">//++(*_pCount);</span></span><br><span class="line"><span class="keyword">if</span> (_ptr != sp._ptr)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//所以要先对我们sp1原先所指向的空间的计数统计减1</span></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">Release</span>();</span><br><span class="line"></span><br><span class="line">_ptr = sp._ptr;</span><br><span class="line">_pCount = sp._pCount;</span><br><span class="line">_pMtx = sp._pMtx;</span><br><span class="line"><span class="comment">//++(*_pCount);</span></span><br><span class="line"><span class="built_in">AddUseCount</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">T* <span class="keyword">operator</span>-&gt;()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _ptr;</span><br><span class="line">&#125;</span><br><span class="line">T&amp; <span class="keyword">operator</span>*()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> *_ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">T* <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对于智能指针不要去做狗拿耗子的事情，他最重要的就是1.帮别人去释放资源2.保证好自己引用计数的线程安全问题</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">use_count</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> *_pCount;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T* _ptr;</span><br><span class="line"><span class="comment">//引用计数，因为定义的对象里面的_ptr都指向同一块空间，但是只有当最后一个指向的对象才去进行释放空间</span></span><br><span class="line"><span class="comment">//使用static成员变量不仅仅属于这个类，还属于这个类的所有对象，这种方式是不对的</span></span><br><span class="line"><span class="type">int</span>* _pCount;<span class="comment">//让第一个开辟一个计数空间，然后让后面所有指向这块空间的也都指向这个技术空间，最后一个将这两块空间都进行释放</span></span><br><span class="line">mutex* _pMtx;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Date</span>&#123;</span><br><span class="line"><span class="type">int</span> _year = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> _month = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> _day = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SharePtrFunc</span><span class="params">(shared_ptr&lt;Date&gt;&amp; sp, <span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//cout &lt;&lt; sp.get() &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 这里智能指针拷贝会++计数，智能指针析构会--计数，这里是线程安全的。</span></span><br><span class="line"><span class="comment">//要保证引用计数的线程安全</span></span><br><span class="line"><span class="function">shared_ptr&lt;Date&gt; <span class="title">copy</span><span class="params">(sp)</span></span>;</span><br><span class="line"><span class="comment">// 这里智能指针访问管理的资源，不是线程安全的。所以我们看看这些值两个线程++了2n次，但</span></span><br><span class="line"><span class="comment">//是最终看到的结果，并一定是加了2n</span></span><br><span class="line">copy-&gt;_year++;</span><br><span class="line">copy-&gt;_month++;</span><br><span class="line">copy-&gt;_day++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test_shared_ptr_safe</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">shared_ptr&lt;Date&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> Date)</span></span>;</span><br><span class="line"><span class="comment">//cout &lt;&lt; p.get() &lt;&lt; endl;</span></span><br><span class="line">cout &lt;&lt; p.<span class="built_in">use_count</span>() &lt;&lt; endl; <span class="comment">//一进来new的那个Date，所以这里应该为1</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> n = <span class="number">10000</span>;</span><br><span class="line"><span class="function">thread <span class="title">t1</span><span class="params">(SharePtrFunc, p, n)</span></span>;</span><br><span class="line"><span class="function">thread <span class="title">t2</span><span class="params">(SharePtrFunc, p, n)</span></span>; </span><br><span class="line">t1.<span class="built_in">join</span>();</span><br><span class="line">t2.<span class="built_in">join</span>();</span><br><span class="line">cout &lt;&lt; p-&gt;_year &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; p-&gt;_month &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; p-&gt;_day &lt;&lt; endl;</span><br><span class="line"><span class="comment">//两个线程分别对年月日都进行了++100次的操作</span></span><br><span class="line">cout &lt;&lt; p.<span class="built_in">use_count</span>() &lt;&lt; endl;<span class="comment">//最终结尾还有还有一个p指针指向Date所以也应该为1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h3><p>1.智能指针对象中引用计数是多个智能指针对象共享的，两个线程中智能指针的引用计数同时++或–-，这个操作不是原子的，引用计数原来是1，++了两次，可能还是2。这样引用计数就错乱了。会导致资源未释放或者程序崩溃的问题。所以只能指针中引用计数++、–是需要加锁（但是引用计数是在堆上开辟的资源，所以为了能够确保使用同一把锁，锁资源也应该在堆上进行开辟）的，也就是说引用计数的操作是线程安全的。<br>2.智能指针管理的对象存放在堆上，两个线程中同时去访问，会导致线程安全问题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;shared-ptr的原理：&quot;&gt;&lt;a href=&quot;#shared-ptr的原理：&quot; class=&quot;headerlink&quot; title=&quot;shared_ptr的原理：&quot;&gt;&lt;/a&gt;shared_ptr的原理：&lt;/h3&gt;&lt;p&gt;通过引用计数的方式来实现多个shared_p</summary>
      
    
    
    
    <category term="C++学习笔记" scheme="http://pachi-33.github.io/categories/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="智能指针" scheme="http://pachi-33.github.io/tags/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>C++11并发与多线程学习记录(一)</title>
    <link href="http://pachi-33.github.io/2022/08/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B1/"/>
    <id>http://pachi-33.github.io/2022/08/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B1/</id>
    <published>2022-08-14T02:20:10.000Z</published>
    <updated>2022-08-24T15:50:12.614Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前在玩unity的时候就觉得多线程给编程带来的影响是巨大的，暑假实训的时候发现有同学竟然在项目里用了多线程，多少有些被惊到了吧，于是下定决心要在暑假恶补这方面的知识。</p><h2 id="并发、进程、线程的基本概念"><a href="#并发、进程、线程的基本概念" class="headerlink" title="并发、进程、线程的基本概念"></a>并发、进程、线程的基本概念</h2><p><strong>并发</strong>：在一个程序中同时进行多个独立的任务。</p><p>​过去CPU只有单核，操作系统实现多任务的方式叫做“上下文切换”，每秒钟进行多次快速的“任务切换”，这是一种伪并发，操作系统需要保存切换时的各种状态、执行进度的等信息，必然造成额外的时间开销。</p><p><strong>进程</strong>：运行起来的可执行程序，运行一个可执行程序便创建了一个进程。</p><p><strong>线程</strong>：代码的执行路径，也就是真正执行代码的东西。</p><p>​每个进程都有一个主线程，这个主线程对于进程而言是唯一的。当产生进程后，它的主线程便自动启动，运行程序时实际上是主线程在调用main()函数，因此进程的寿命有多长，主线程的寿命就有多长，两者同时存在、同时消失。除了主线程之外，还可以创建其它线程，每创建一个新线程便可以同时多执行一支代码。</p><p>​然而线程不是越多越好，但每个线程都需要独立的、额外的栈空间（划重点！！），线程之间的切换需要保存中间状态，会耗费程序运行的时间，一般在实际项目中要把线程数量控制在200-300个以内，具体数量需要不断测试优化。</p><h2 id="并发的实现方法"><a href="#并发的实现方法" class="headerlink" title="并发的实现方法"></a>并发的实现方法</h2><ol><li><p>产生多个进程；</p></li><li><p>在单个进程中创建多个线程，自己写代码来创建主线程之外的线程。</p></li></ol><h3 id="多进程并发"><a href="#多进程并发" class="headerlink" title="多进程并发"></a><strong>多进程并发</strong></h3><p>进程之间进行通信（在同一电脑上的方法有管道、文件、消息队列、共享内存等；不同电脑上则有socket通信技术 ）。</p><h3 id="多线程并发"><a href="#多线程并发" class="headerlink" title="多线程并发"></a><strong>多线程并发</strong></h3><p>​在单个进程中创建多个线程。</p><p>​一个进程中的所有线程共享内存。全局变量、指针、引用 都可以在线程间传递，因此使用多线程开销远小于多进程。但也带来了数据一致性问题。</p><h4 id="数据一致性问题"><a href="#数据一致性问题" class="headerlink" title="数据一致性问题"></a>数据一致性问题</h4><p>​现有线程A、线程B，两者虽共享一片内存，但要注意不能同时操作一块内存，必须有先有后。</p><h2 id="C-11新标准线程库"><a href="#C-11新标准线程库" class="headerlink" title="C++11新标准线程库"></a>C++11新标准线程库</h2><p>以往windows中有：<code>CreateThread();  _beginthread();  _beginthreadexe()</code>; </p><p>Linux中有： <code>pthread_create()</code>; 来创建线程。</p><p>因此以往多线程代码不能跨平台运行</p><p>好消息是，从C++11开始，C++语言本身增加了对多线程的支持，实现了可移植性。</p><h4 id="线程的开始和结束"><a href="#线程的开始和结束" class="headerlink" title="线程的开始和结束"></a>线程的开始和结束</h4><p>​程序运行起来，生成一个进程，其所属的主线程自动开始运行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cout&lt;&lt;<span class="string">&quot;Hello World!&quot;</span>&lt;&lt;endl; <span class="comment">//主线程在执行，结束时从main()返回，进程结束</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​主线程从main()开始执行，我们创建的线程也需要从一个函数开始运行。</p><h3 id="如何创建线程？"><a href="#如何创建线程？" class="headerlink" title="如何创建线程？"></a>如何创建线程？</h3><p>​（1）包含thread头文件；</p><p>​（2）定义初始函数；</p><h5 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h5><p>​join: 加入&#x2F;汇合，阻塞主线程，让主程序等待子线程执行完毕，子线程结束后转移回主线程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myprint</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cout&lt;&lt;<span class="string">&quot;我的线程开始了&quot;</span>&lt;&lt;endl;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  cout&lt;&lt;<span class="string">&quot;我的线程结束了&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="function">thread <span class="title">mythread</span><span class="params">(myprint)</span></span>;<span class="comment">//线程执行入口myprint(),创建thread对象，myprint是可调用对象,myprint()开始执行</span></span><br><span class="line">  mythread.<span class="built_in">join</span>();<span class="comment">//阻塞主线程</span></span><br><span class="line">  cout&lt;&lt;<span class="string">&quot;Hello World!&quot;</span>&lt;&lt;endl; </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="detach"><a href="#detach" class="headerlink" title="detach()"></a>detach()</h5><p>​detach: 分离&#x2F;摆脱，主线程不和子线程汇合，主线程不必等子线程结束。</p><p>​一旦detach()之后，与主线程关联的thread对象就会失去和主线程的关联，这个子线程就被c++运行时库接管，在系统后台运行，子线程执行完成后，由运行时库负责清理该线程相关的资源。</p><p>​一旦调用join()，就不能调用detach()。</p><h5 id="joinable"><a href="#joinable" class="headerlink" title="joinable()"></a>joinable()</h5><p>​joinable: 判断是否可以成功使用join()或detach(), 返回true或false。</p><h3 id="其它创建子线程的方法"><a href="#其它创建子线程的方法" class="headerlink" title="其它创建子线程的方法"></a>其它创建子线程的方法</h3><h4 id="用类对象："><a href="#用类对象：" class="headerlink" title="用类对象："></a>用类对象：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TA</span></span><br><span class="line">&#123; </span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;我的线程operator()开始执行了&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;我的线程operator()结束执行了&quot;</span>&lt;&lt;endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  TA ta;<span class="comment">//可调用对象</span></span><br><span class="line">  <span class="function">thread <span class="title">mythread</span><span class="params">(ta)</span></span>;</span><br><span class="line">  mythread.<span class="built_in">join</span>();</span><br><span class="line">  cout&lt;&lt;<span class="string">&quot;Hello World!&quot;</span>&lt;&lt;endl;</span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="用lambda表达式"><a href="#用lambda表达式" class="headerlink" title="用lambda表达式"></a>用lambda表达式</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> myLamThread=[]&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;开始执行&quot;</span>&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;结束执行&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">thread <span class="title">myThread</span><span class="params">(myLamThread)</span></span>;</span><br><span class="line">    myThread.<span class="built_in">join</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;之前在玩unity的时候就觉得多线程给编程带来的影响是巨大的，暑假实训的时候发现有同学竟然在项目里用了多线程，多少有些被惊到了吧，于是下定决</summary>
      
    
    
    
    <category term="C++学习笔记" scheme="http://pachi-33.github.io/categories/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="多线程" scheme="http://pachi-33.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>C++11 auto关键字</title>
    <link href="http://pachi-33.github.io/2022/06/30/auto%E5%9F%BA%E7%A1%80/"/>
    <id>http://pachi-33.github.io/2022/06/30/auto%E5%9F%BA%E7%A1%80/</id>
    <published>2022-06-30T14:32:03.000Z</published>
    <updated>2022-08-14T02:30:07.720Z</updated>
    
    <content type="html"><![CDATA[<h2 id="自动匹配变量类型"><a href="#自动匹配变量类型" class="headerlink" title="自动匹配变量类型"></a>自动匹配变量类型</h2><p>auto可以在声明变量的时候根据变量初始值的类型自动为此变量选择匹配的类型，类似的关键字还有decltype。举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">auto</span> au_a = a;<span class="comment">//自动类型推断，au_a为int类型</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">typeid</span>(au_a).<span class="built_in">name</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>typeid运算符可以输出变量的类型。程序的运行结果输出了</p><blockquote><p>int</p></blockquote><p>这种用法就类似于C#中的var关键字。auto的自动类型推断发生在编译期，所以使用auto并不会造成程序运行时效率的降低。而是否会造成编译期的时间消耗，我认为是不会的，在未使用auto时，编译器也需要得知右操作数的类型，再与左操作数的类型进行比较，检查是否可以发生相应的转化，是否需要进行隐式类型转换。</p><h2 id="auto的用法"><a href="#auto的用法" class="headerlink" title="auto的用法"></a>auto的用法</h2><p>上面举的这个例子很简单，在真正编程的时候也不建议这样来使用auto，直接写出变量的类型更加清晰易懂。下面列举auto关键字的正确用法。</p><h3 id="用于代替冗长复杂、变量使用范围专一的变量声明。"><a href="#用于代替冗长复杂、变量使用范围专一的变量声明。" class="headerlink" title="用于代替冗长复杂、变量使用范围专一的变量声明。"></a>用于代替冗长复杂、变量使用范围专一的变量声明。</h3><p>想象一下在没有auto的时候，我们操作标准库时经常需要这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;std::string&gt; vs;</span><br><span class="line">    <span class="keyword">for</span> (std::vector&lt;std::string&gt;::iterator i = vs.<span class="built_in">begin</span>(); i != vs.<span class="built_in">end</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样看代码写代码实在烦得很。有人可能会说为何不直接使用using namespace std，这样代码可以短一点。实际上这不是该建议的方法（C++Primer对此有相关叙述）。使用auto能简化代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;std::string&gt; vs;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = vs.<span class="built_in">begin</span>(); i != vs.<span class="built_in">end</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//..</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for循环中的i将在编译时自动推导其类型，而不用我们显式去定义那长长的一串。</p><h3 id="在定义模板函数时，用于声明依赖模板参数的变量类型。"><a href="#在定义模板函数时，用于声明依赖模板参数的变量类型。" class="headerlink" title="在定义模板函数时，用于声明依赖模板参数的变量类型。"></a>在定义模板函数时，用于声明依赖模板参数的变量类型。</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tx,<span class="keyword">typename</span> _Ty&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Multiply</span><span class="params">(_Tx x, _Ty y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> v = x*y;</span><br><span class="line">    std::cout &lt;&lt; v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若不使用auto变量来声明v，那这个函数就难定义啦，不到编译的时候，谁知道x*y的真正类型是什么呢？</p><h3 id="模板函数依赖于模板参数的返回值"><a href="#模板函数依赖于模板参数的返回值" class="headerlink" title="模板函数依赖于模板参数的返回值"></a>模板函数依赖于模板参数的返回值</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tx, <span class="keyword">typename</span> _Ty&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">multiply</span><span class="params">(_Tx x, _Ty y)</span>-&gt;<span class="title">decltype</span><span class="params">(_Tx*_Ty)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x*y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当模板函数的返回值依赖于模板的参数时，我们依旧无法在编译代码前确定模板参数的类型，故也无从知道返回值的类型，这时我们可以使用auto。格式如上所示。<br>decltype操作符用于查询表达式的数据类型，也是C++11标准引入的新的运算符，其目的也是解决泛型编程中有些类型由模板参数决定，而难以表示它的问题。<br>auto在这里的作用也称为<strong>返回值占位</strong>，它只是为函数返回值占了一个位置，真正的返回值是后面的decltype(_Tx*_Ty)。为何要将返回值后置呢？如果没有后置，则函数声明时为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(_Tx*_Ty)<span class="built_in">multiply</span>(_Tx x, _Ty y)</span><br></pre></td></tr></table></figure><p>而此时_Tx,_Ty还没声明呢，编译无法通过。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>auto 变量必须在定义时初始化，这类似于const关键字。</li><li>定义在一个auto序列的变量必须始终推导成同一类型。例如：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> a4 = <span class="number">10</span>, a5 = <span class="number">20</span>, a6 = <span class="number">30</span>;<span class="comment">//正确</span></span><br><span class="line"><span class="keyword">auto</span> b4 = <span class="number">10</span>, b5 = <span class="number">20.0</span>, b6 = <span class="string">&#x27;a&#x27;</span>;<span class="comment">//错误,没有推导为同一类型</span></span><br></pre></td></tr></table></figure><p>使用auto关键字做类型自动推导时，依次施加一下规则：</p><ul><li>如果初始化表达式是引用，则去除引用语义。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> &amp;b = a;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">auto</span> c = b;<span class="comment">//c的类型为int而非int&amp;（去除引用）</span></span><br><span class="line"><span class="keyword">auto</span> &amp;d = b;<span class="comment">//此时c的类型才为int&amp;</span></span><br><span class="line"> </span><br><span class="line">c = <span class="number">100</span>;<span class="comment">//a =10;</span></span><br><span class="line">d = <span class="number">100</span>;<span class="comment">//a =100;</span></span><br></pre></td></tr></table></figure><ul><li>如果初始化表达式为const或volatile（或者两者兼有），则除去const&#x2F;volatile语义。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a1 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">auto</span>  b1= a1; <span class="comment">//b1的类型为int而非const int（去除const）</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> c1 = a1;<span class="comment">//此时c1的类型为const int</span></span><br><span class="line">b1 = <span class="number">100</span>;<span class="comment">//合法</span></span><br><span class="line">c1 = <span class="number">100</span>;<span class="comment">//非法</span></span><br></pre></td></tr></table></figure><ul><li>如果auto关键字带上&amp;号，则不去除const语意。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a2 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">auto</span> &amp;b2 = a2;<span class="comment">//因为auto带上&amp;，故不去除const，b2类型为const int</span></span><br><span class="line">b2 = <span class="number">10</span>; <span class="comment">//非法</span></span><br></pre></td></tr></table></figure><p>这是因为如何去掉了const，则b2为a2的非const引用，通过b2可以改变a2的值，则显然是不合理的。</p><ul><li>初始化表达式为数组时，auto关键字推导类型为指针。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a3[<span class="number">3</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="keyword">auto</span> b3 = a3;</span><br><span class="line">cout &lt;&lt; <span class="built_in">typeid</span>(b3).<span class="built_in">name</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>程序将输出</p><blockquote><p>int *</p></blockquote><ul><li>若表达式为数组且auto带上&amp;，则推导类型为数组类型。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a7[<span class="number">3</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="keyword">auto</span> &amp; b7 = a7;</span><br><span class="line">cout &lt;&lt; <span class="built_in">typeid</span>(b7).<span class="built_in">name</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>程序输出</p><blockquote><p>int [3]</p></blockquote><ul><li>函数或者模板参数不能被声明为auto</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="keyword">auto</span> a)</span>  <span class="comment">//错误</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时刻要注意auto并不是一个真正的类型。<br>auto仅仅是一个占位符，它并不是一个真正的类型，不能使用一些以类型为操作数的操作符，如sizeof或者typeid。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="keyword">auto</span>) &lt;&lt; endl;<span class="comment">//错误</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">typeid</span>(<span class="keyword">auto</span>).<span class="built_in">name</span>() &lt;&lt; endl;<span class="comment">//错误</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;自动匹配变量类型&quot;&gt;&lt;a href=&quot;#自动匹配变量类型&quot; class=&quot;headerlink&quot; title=&quot;自动匹配变量类型&quot;&gt;&lt;/a&gt;自动匹配变量类型&lt;/h2&gt;&lt;p&gt;auto可以在声明变量的时候根据变量初始值的类型自动为此变量选择匹配的类型，类似的关键字还有</summary>
      
    
    
    
    <category term="C++基础" scheme="http://pachi-33.github.io/categories/C-%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="auto" scheme="http://pachi-33.github.io/tags/auto/"/>
    
  </entry>
  
  <entry>
    <title>C++基础之仿函数和lambda表达式</title>
    <link href="http://pachi-33.github.io/2022/06/27/%E4%BB%BF%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/"/>
    <id>http://pachi-33.github.io/2022/06/27/%E4%BB%BF%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/</id>
    <published>2022-06-27T03:53:04.000Z</published>
    <updated>2022-08-14T02:55:35.985Z</updated>
    
    <content type="html"><![CDATA[<h2 id="仿函数"><a href="#仿函数" class="headerlink" title="仿函数"></a>仿函数</h2><h3 id="为什么要有仿函数"><a href="#为什么要有仿函数" class="headerlink" title="为什么要有仿函数"></a>为什么要有仿函数</h3><p>​我们先从一个非常简单的问题入手，来了解为什么要有仿函数。</p><p>​假设我们现在有一个数组，数组中存有任意数量的数字，我们希望能够统计出这个数组中大于 10 的数字的数量，你的代码很可能是这样的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">RecallFunc</span><span class="params">(<span class="type">int</span> *start, <span class="type">int</span> *end, <span class="type">bool</span> (*pf)(<span class="type">int</span>))</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> *i = start; i != end+<span class="number">1</span>; i++) &#123;</span><br><span class="line">    count = <span class="built_in">pf</span>(*i) ? count+<span class="number">1</span> : count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsGreaterThanTen</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> num&gt;<span class="number">10</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">10</span>,<span class="number">100</span>,<span class="number">11</span>,<span class="number">5</span>,<span class="number">19</span>&#125;;</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">RecallFunc</span>(a, a+<span class="number">4</span>, IsGreaterThanTen);</span><br><span class="line">    cout&lt;&lt;result&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​<code>RecallFunc()</code> 函数的第三个参数是一个函数指针，用于外部调用，而 <code>IsGreaterThanTen()</code> 函数通常也是外部已经定义好的，它只接受一个参数的函数。如果此时希望将判定的阈值也作为一个变量传入，变为如下函数就不可行了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsGreaterThanThreshold</span><span class="params">(<span class="type">int</span> num, <span class="type">int</span> threshold)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> num&gt;threshold ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​虽然这个函数看起来比前面一个版本更具有一般性，但是它不能满足已经定义好的函数指针参数的要求，因为函数指针参数的类型是<code>bool (*)(int)</code>，与函数<code>bool IsGreaterThanThreshold(int num, int threshold)</code>的类型不相符。如果一定要完成这个任务，按照以往的经验，我们可以考虑如下可能途径：</p><p>（1）阈值作为函数的局部变量。局部变量不能在函数调用中传递，故不可行；</p><p>（2）函数传参。这种方法我们已经讨论过了，多个参数不适用于已定义好的 <code>RecallFunc()</code> 函数。</p><p>（3）全局变量。我们可以将阈值设置成一个全局变量。这种方法虽然可行，但不优雅，且容易引入 Bug，比如全局变量容易同名，造成命名空间污染。</p><p>还有什么好的处理办法呢？仿函数应运而生。</p><h3 id="仿函数的定义"><a href="#仿函数的定义" class="headerlink" title="仿函数的定义"></a>仿函数的定义</h3><p>​仿函数<code>（Functor）</code>又称为函数对象（Function Object）是一个能行使函数功能的类。</p><p>​仿函数的语法几乎和我们普通的函数调用一样，不过作为仿函数的类，都必须重载 operator() 运算符。因为调用仿函数，实际上就是通过类对象调用重载后的 operator() 运算符。</p><p>​如果编程者要将某种“操作”当做算法的参数，一般有两种方法：</p><p>（1）一个办法就是先将该“操作”设计为一个函数，再将函数指针当做算法的一个参数。上面的实例就是该做法；</p><p>（2）将该“操作”设计为一个仿函数（就语言层面而言是个 class），再以该仿函数产生一个对象，并以此对象作为算法的一个参数。</p><p>​很明显第二种方法会更优秀，因为第一种方法扩展性较差，当函数参数有所变化，则无法兼容旧的代码，具体在第一小节已经阐述。正如上面的例子，在我们写代码时有时会发现有些功能代码，会不断地被使用。为了复用这些代码，实现为一个公共的函数是一个解决方法。不过函数用到的一些变量，可能是公共的全局变量。引入全局变量，容易出现同名冲突，不方便维护。</p><p>​这时就可以使用仿函数了，写一个简单类，除了维护类的基本成员函数外，只需要重载 operator() 运算符 。这样既可以免去对一些公共变量的维护，也可以使重复使用的代码独立出来，以便下次复用。而且相对于函数更优秀的性质，仿函数还可以进行依赖、组合与继承等，这样有利于资源的管理。如果再配合模板技术和 Policy 编程思想，则更加威力无穷，大家可以慢慢体会。Policy 表述了泛型函数和泛型类的一些可配置行为（通常都具有被经常使用的缺省值）。</p><p>​STL 中也大量涉及到仿函数，有时仿函数的使用是为了函数拥有类的性质，以达到安全传递函数指针、依据函数生成对象、甚至是让函数之间有继承关系、对函数进行运算和操作的效果。比如 STL 中的容器 set 就使用了仿函数 less ，而 less 继承的 binary_function，就可以看作是对于一类函数的总体声明，这是函数做不到的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// less的定义</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt; <span class="keyword">struct</span> <span class="title class_">less</span> : <span class="keyword">public</span> binary_function&lt;_Tp, _Tp, <span class="type">bool</span>&gt; &#123;</span><br><span class="line">      <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> _Tp&amp; __x, <span class="type">const</span> _Tp&amp; __y)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">      </span>&#123; <span class="keyword">return</span> __x &lt; __y; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// set 的申明</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Key, <span class="keyword">typename</span> _Compare = std::less&lt;_Key&gt;,<span class="keyword">typename</span> _Alloc = std::allocator&lt;_Key&gt;&gt; <span class="keyword">class</span> set;</span><br></pre></td></tr></table></figure><p>​仿函数中的变量可以是 static 的，同时仿函数还给出了 static 的替代方案，仿函数内的静态变量可以改成类的私有成员，这样可以明确地在析构函数中清除所用内容，如果用到了指针，那么这个是不错的选择。有人说这样的类已经不是仿函数了，但其实，封装后从外界观察，可以明显地发现，它依然有函数的性质。</p><h3 id="仿函数实例"><a href="#仿函数实例" class="headerlink" title="仿函数实例"></a>仿函数实例</h3><p>我们先来看一个仿函数的例子。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StringAppend</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">StringAppend</span><span class="params">(<span class="type">const</span> string&amp; str)</span> : ss(str)&#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">const</span> string&amp; str)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">         cout &lt;&lt; str &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; ss &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> string ss;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">StringAppend <span class="title">myFunctor2</span><span class="params">(<span class="string">&quot;and world!&quot;</span>)</span></span>;</span><br><span class="line">    <span class="built_in">myFunctor2</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行输出：</p><p><code>Hello and world!</code></p><p>​这个例子应该可以让您体会到仿函数的一些作用：它既能像普通函数一样传入给定数量的参数，还能存储或者处理更多我们需要的有用信息。于是仿函数提供了第四种解决方案：成员变量。成员函数可以很自然地访问成员变量，从而可以解决第一节“1.为什么要有仿函数”中提到的问题：计算出数组中大于指定阈值的数字数量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IsGreaterThanThresholdFunctor</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">IsGreaterThanThresholdFunctor</span><span class="params">(<span class="type">int</span> t)</span>:threshold(t)&#123;</span>&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">int</span> num)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> num &gt; threshold ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> threshold;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">RecallFunc</span><span class="params">(<span class="type">int</span> *start, <span class="type">int</span> *end, IsGreaterThanThresholdFunctor myFunctor)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> *i = start; i != end + <span class="number">1</span>; i++) &#123;</span><br><span class="line">count = <span class="built_in">myFunctor</span>(*i) ? count + <span class="number">1</span> : count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">10</span>,<span class="number">100</span>,<span class="number">11</span>,<span class="number">5</span>,<span class="number">19</span>&#125;;</span><br><span class="line"><span class="type">int</span> result = <span class="built_in">RecallFunc</span>(a, a + <span class="number">4</span>, <span class="built_in">IsGreaterThanThresholdFunctor</span>(<span class="number">10</span>));</span><br><span class="line">cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行输出：</p><p><code>3</code></p><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>​C++11的一大亮点就是引入了Lambda表达式。利用Lambda表达式，可以方便的定义和创建匿名函数。对于C++这门语言来说来说，“Lambda表达式”或“匿名函数”这些概念听起来好像很深奥，但很多高级语言在很早以前就已经提供了Lambda表达式的功能，如C#，Python等。今天，我们就来简单介绍一下C++中Lambda表达式的简单使用。</p><p>声明Lambda表达式<br>Lambda表达式完整的声明格式如下：</p><p><code>[capture list] (params list) mutable exception-&gt; return type &#123; function body &#125;</code></p><p>各项具体含义如下</p><ol><li><p>capture list：捕获外部变量列表</p></li><li><p>params list：形参列表</p></li><li><p>mutable指示符：用来说用是否可以修改捕获的变量</p></li><li><p>exception：异常设定</p></li><li><p>return type：返回类型</p></li><li><p>function body：函数体</p></li></ol><p>此外，我们还可以省略其中的某些成分来声明“不完整”的Lambda表达式，常见的有以下几种：</p><table><thead><tr><th>序号</th><th>格式</th></tr></thead><tbody><tr><td>1</td><td>[capture list] (params list) -&gt; return type {function body}</td></tr><tr><td>2</td><td>[capture list] (params list) {function body}</td></tr><tr><td>3</td><td>[capture list] {function body}</td></tr></tbody></table><p>其中：</p><p>格式1声明了const类型的表达式，这种类型的表达式不能修改捕获列表中的值。<br>格式2省略了返回值类型，但编译器可以根据以下规则推断出Lambda表达式的返回类型：</p><p> （1）：如果function body中存在return语句，则该Lambda表达式的返回类型由return语句的返回类型确定；</p><p> （2）：如果function body中没有return语句，则返回值为void类型。<br>格式3中省略了参数列表，类似普通函数中的无参函数。</p><p>讲了这么多，我们还没有看到Lambda表达式的庐山真面目，下面我们就举一个实例。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>using namespace std;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>  a &lt; b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; myvec&#123; <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">2</span> &#125;;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">lbvec</span><span class="params">(myvec)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(myvec.<span class="built_in">begin</span>(), myvec.<span class="built_in">end</span>(), cmp); <span class="comment">// 旧式做法</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;predicate function:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> it : myvec)</span><br><span class="line">        cout &lt;&lt; it &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">     </span><br><span class="line">    <span class="built_in">sort</span>(lbvec.<span class="built_in">begin</span>(), lbvec.<span class="built_in">end</span>(), [](<span class="type">int</span> a, <span class="type">int</span> b) -&gt; <span class="type">bool</span> &#123; <span class="keyword">return</span> a &lt; b; &#125;);   <span class="comment">// Lambda表达式</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;lambda expression:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> it : lbvec)</span><br><span class="line">        cout &lt;&lt; it &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​在C++11之前，我们使用STL的sort函数，需要提供一个谓词函数。如果使用C++11的Lambda表达式，我们只需要传入一个匿名函数即可，方便简洁，而且代码的可读性也比旧式的做法好多了。</p><p>下面，我们就重点介绍一下Lambda表达式各项的具体用法。</p><h3 id="捕获外部变量"><a href="#捕获外部变量" class="headerlink" title="捕获外部变量"></a>捕获外部变量</h3><p>Lambda表达式可以使用其可见范围内的外部变量，但必须明确声明（明确声明哪些外部变量可以被该Lambda表达式使用）。那么，在哪里指定这些外部变量呢？Lambda表达式通过在最前面的方括号[]来明确指明其内部可以访问的外部变量，这一过程也称过Lambda表达式“捕获”了外部变量。</p><p>我们通过一个例子来直观地说明一下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>using namespace std;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">auto</span> f = [a] &#123; cout &lt;&lt; a &lt;&lt; endl; &#125;; </span><br><span class="line">    <span class="built_in">f</span>(); <span class="comment">// 输出：123</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//或通过“函数体”后面的‘()’传入参数</span></span><br><span class="line">    <span class="keyword">auto</span> x = [](<span class="type">int</span> a)&#123;cout &lt;&lt; a &lt;&lt; endl;&#125;(<span class="number">123</span>); </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个例子先声明了一个整型变量a，然后再创建Lambda表达式，该表达式“捕获”了a变量，这样在Lambda表达式函数体中就可以获得该变量的值。</p><p>类似参数传递方式（值传递、引入传递、指针传递），在Lambda表达式中，外部变量的捕获方式也有值捕获、引用捕获、隐式捕获。</p><h4 id="值捕获"><a href="#值捕获" class="headerlink" title="值捕获"></a>值捕获</h4><p>​值捕获和参数传递中的值传递类似，被捕获的变量的值在Lambda表达式创建时通过值拷贝的方式传入，因此随后对该变量的修改不会影响影响Lambda表达式中的值。</p><p>示例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">auto</span> f = [a] &#123; cout &lt;&lt; a &lt;&lt; endl; &#125;; </span><br><span class="line">    a = <span class="number">321</span>;</span><br><span class="line">    <span class="built_in">f</span>(); <span class="comment">// 输出：123</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要注意的是，如果以传值方式捕获外部变量，则在Lambda表达式函数体中不能修改该外部变量的值。</p><h4 id="引用捕获"><a href="#引用捕获" class="headerlink" title="引用捕获"></a>引用捕获</h4><p>使用引用捕获一个外部变量，只需要在捕获列表变量前面加上一个引用说明符&amp;。如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">auto</span> f = [&amp;a] &#123; cout &lt;&lt; a &lt;&lt; endl; &#125;; </span><br><span class="line">    a = <span class="number">321</span>;</span><br><span class="line">    <span class="built_in">f</span>(); <span class="comment">// 输出：321</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从示例中可以看出，引用捕获的变量使用的实际上就是该引用所绑定的对象。</p><h4 id="隐式捕获"><a href="#隐式捕获" class="headerlink" title="隐式捕获"></a>隐式捕获</h4><p>​上面的值捕获和引用捕获都需要我们在捕获列表中显示列出Lambda表达式中使用的外部变量。除此之外，我们还可以让编译器根据函数体中的代码来推断需要捕获哪些变量，这种方式称之为隐式捕获。隐式捕获有两种方式，分别是[&#x3D;]和[&amp;]。[&#x3D;]表示以值捕获的方式捕获外部变量，[&amp;]表示以引用捕获的方式捕获外部变量。</p><p>隐式值捕获示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">auto</span> f = [=] &#123; cout &lt;&lt; a &lt;&lt; endl; &#125;;    <span class="comment">// 值捕获</span></span><br><span class="line">    <span class="built_in">f</span>(); <span class="comment">// 输出：123</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>隐式引用捕获示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">auto</span> f = [&amp;] &#123; cout &lt;&lt; a &lt;&lt; endl; &#125;;    <span class="comment">// 引用捕获</span></span><br><span class="line">    a = <span class="number">321</span>;</span><br><span class="line">    <span class="built_in">f</span>(); <span class="comment">// 输出：321</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="混合方式"><a href="#混合方式" class="headerlink" title="混合方式"></a>混合方式</h4><p>​上面的例子，要么是值捕获，要么是引用捕获，Lambda表达式还支持混合的方式捕获外部变量，这种方式主要是以上几种捕获方式的组合使用。</p><p>到这里，我们来总结一下：C++11中的Lambda表达式捕获外部变量主要有以下形式：</p><table><thead><tr><th>捕获形式</th><th>说明</th></tr></thead><tbody><tr><td>[]</td><td>不捕获任何外部变量</td></tr><tr><td>[变量名, …]</td><td>默认以值得形式捕获指定的多个外部变量（用逗号分隔），如果引用捕获，需要显示声明（使用&amp;说明符）</td></tr><tr><td>[this]</td><td>以值的形式捕获this指针</td></tr><tr><td>[&#x3D;]</td><td>以值的形式捕获所有外部变量</td></tr><tr><td>[&amp;]</td><td>以引用形式捕获所有外部变量</td></tr><tr><td>[&#x3D;, &amp;x]</td><td>变量x以引用形式捕获，其余变量以传值形式捕获</td></tr><tr><td>[&amp;, x]</td><td>变量x以值的形式捕获，其余变量以引用形式捕获</td></tr></tbody></table><h3 id="修改捕获变量"><a href="#修改捕获变量" class="headerlink" title="修改捕获变量"></a>修改捕获变量</h3><p>​前面我们提到过，在Lambda表达式中，如果以传值方式捕获外部变量，则函数体中不能修改该外部变量，否则会引发编译错误。那么有没有办法可以修改值捕获的外部变量呢？这是就需要使用mutable关键字，该关键字用以说明表达式体内的代码可以修改值捕获的变量，示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">auto</span> f = [a]()<span class="keyword">mutable</span> &#123; cout &lt;&lt; ++a; &#125;; <span class="comment">// 不会报错</span></span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl; <span class="comment">// 输出：123</span></span><br><span class="line">    <span class="built_in">f</span>(); <span class="comment">// 输出：124</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Lambda表达式的参数"><a href="#Lambda表达式的参数" class="headerlink" title="Lambda表达式的参数"></a>Lambda表达式的参数</h3><p>Lambda表达式的参数和普通函数的参数类似，那么这里为什么还要拿出来说一下呢？原因是在Lambda表达式中传递参数还有一些限制，主要有以下几点：</p><ol><li>参数列表中不能有默认参数</li><li>不支持可变参数</li><li>所有参数必须有参数名</li></ol><p>常用举例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">　 <span class="type">int</span> m = [](<span class="type">int</span> x) &#123; <span class="keyword">return</span> [](<span class="type">int</span> y) &#123; <span class="keyword">return</span> y * <span class="number">2</span>; &#125;(x)+<span class="number">6</span>; &#125;(<span class="number">5</span>);</span><br><span class="line">   std::cout &lt;&lt; <span class="string">&quot;m:&quot;</span> &lt;&lt; m &lt;&lt; std::endl; <span class="comment">//输出m:16</span></span><br><span class="line">   std::cout &lt;&lt; <span class="string">&quot;n:&quot;</span> &lt;&lt; [](<span class="type">int</span> x, <span class="type">int</span> y) &#123; <span class="keyword">return</span> x + y; &#125;(<span class="number">5</span>, <span class="number">4</span>) &lt;&lt; std::endl; <span class="comment">//输出n:9        </span></span><br><span class="line">   <span class="keyword">auto</span> gFunc = [](<span class="type">int</span> x) -&gt; function&lt;<span class="built_in">int</span>(<span class="type">int</span>)&gt; &#123; <span class="keyword">return</span> [=](<span class="type">int</span> y) &#123; <span class="keyword">return</span> x + y; &#125;; &#125;;</span><br><span class="line">   <span class="keyword">auto</span> lFunc = <span class="built_in">gFunc</span>(<span class="number">4</span>);</span><br><span class="line">   std::cout &lt;&lt; <span class="built_in">lFunc</span>(<span class="number">5</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">auto</span> hFunc = [](<span class="type">const</span> function&lt;<span class="built_in">int</span>(<span class="type">int</span>)&gt;&amp; f, <span class="type">int</span> z) &#123; <span class="keyword">return</span> <span class="built_in">f</span>(z) + <span class="number">1</span>; &#125;;</span><br><span class="line">   <span class="keyword">auto</span> a = <span class="built_in">hFunc</span>(<span class="built_in">gFunc</span>(<span class="number">7</span>), <span class="number">8</span>);</span><br><span class="line">     </span><br><span class="line">   <span class="type">int</span> a = <span class="number">111</span>, b = <span class="number">222</span>;</span><br><span class="line">   <span class="keyword">auto</span> func = [=, &amp;b]()<span class="keyword">mutable</span> &#123; a = <span class="number">22</span>; b = <span class="number">333</span>; std::cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; std::endl; &#125;;</span><br><span class="line">     </span><br><span class="line">   <span class="built_in">func</span>();</span><br><span class="line">   std::cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; std::endl;</span><br><span class="line">     </span><br><span class="line">   a = <span class="number">333</span>;</span><br><span class="line">   <span class="keyword">auto</span> func2 = [=, &amp;a] &#123; a = <span class="number">444</span>; std::cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; std::endl; &#125;;</span><br><span class="line">   <span class="built_in">func2</span>();</span><br><span class="line">     </span><br><span class="line">   <span class="keyword">auto</span> func3 = [](<span class="type">int</span> x) -&gt;function&lt;<span class="built_in">int</span>(<span class="type">int</span>)&gt; &#123; <span class="keyword">return</span> [=](<span class="type">int</span> y) &#123; <span class="keyword">return</span> x + y; &#125;; &#125;;</span><br><span class="line">　　</span><br><span class="line">　 std::function&lt;<span class="type">void</span>(<span class="type">int</span> x)&gt; f_display_42 = [](<span class="type">int</span> x) &#123; <span class="built_in">print_num</span>(x); &#125;;</span><br><span class="line">   <span class="built_in">f_display_42</span>(<span class="number">44</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;仿函数&quot;&gt;&lt;a href=&quot;#仿函数&quot; class=&quot;headerlink&quot; title=&quot;仿函数&quot;&gt;&lt;/a&gt;仿函数&lt;/h2&gt;&lt;h3 id=&quot;为什么要有仿函数&quot;&gt;&lt;a href=&quot;#为什么要有仿函数&quot; class=&quot;headerlink&quot; title=&quot;为什么要有</summary>
      
    
    
    
    <category term="C++基础" scheme="http://pachi-33.github.io/categories/C-%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="仿函数" scheme="http://pachi-33.github.io/tags/%E4%BB%BF%E5%87%BD%E6%95%B0/"/>
    
    <category term="lambda表达式" scheme="http://pachi-33.github.io/tags/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
</feed>
